import pg from '../../plugins/pg';
import { getTableList, getTableSchema, toPgArray } from '../utils/table';
import {
  addLengthCheck,
  addSizeCheck,
  addRangeCheck,
  specificType,
  DataType,
  Column,
  removeLengthCheck,
  removeRangeCheck,
  removeSizeCheck,
  getConstraintName,
  addDateRangeCheck,
  removeDateRangeCheck,
  ReferentialAction,
  removeOptionsCheck,
  addOptionsCheck,
  addFileCountCheck,
  removeFileCountCheck,
  addEmailDomainCheck,
  removeEmailDomainCheck,
} from '../utils/column';
import { setTableMetadata } from '../db/table-metadata';
import { setColumnMetadata } from '../db/column-metadata';

export class TableService {
  async getAll({ schemaName = 'public' }: { schemaName?: string } = {}) {
    const tables = await getTableList(pg, schemaName);
    return tables;
  }

  async getSchema({
    schemaName = 'public',
    tableName,
  }: {
    schemaName?: string;
    tableName: string;
  }) {
    const exists = await pg.schema.hasTable(tableName);
    if (!exists) throw new Error('Table not found');

    const schema = await getTableSchema(pg, schemaName, tableName);
    return schema;
  }

  async createTable({
    schemaName = 'public',
    tableName,
    tableComment,
    idType = 'integer',
    timestamps = true,
    presentation,
  }: {
    schemaName?: string;
    tableName: string;
    tableComment?: string | null;
    idType?: 'integer' | 'biginteger' | 'uuid' | 'shortid';
    timestamps?: boolean;
    presentation?: {
      uiName?: string;
    } | null;
  }) {
    const fullTableName = `${schemaName}.${tableName}`;
    const schemaBuilder = pg.schema.withSchema(schemaName);

    const exists = await schemaBuilder.hasTable(tableName);
    if (exists) {
      throw new Error(`Table ${fullTableName} already exists`);
    }

    await schemaBuilder.createTable(tableName, (table) => {
      // Define the primary key column based on the selected primaryType
      switch (idType) {
        case 'integer':
          // 32-bit auto-incrementing integer
          // Limited to ~2.1 billion rows – use only for small tables
          table.increments('id').primary();
          break;

        case 'biginteger':
          // Recommended default: 64-bit auto-incrementing integer
          // Supports up to ~9 quintillion rows – safe for large-scale applications
          table.bigIncrements('id').primary();
          break;

        case 'uuid':
          // UUID v4 generated by PostgreSQL (requires pgcrypto extension)
          // Globally unique, ideal for distributed systems
          table.uuid('id').primary().defaultTo(pg.raw('gen_random_uuid()'));
          break;

        case 'shortid':
          // Generates a random ~16-character alphanumeric string (URL-safe)
          // Compact and readable – great for public-facing IDs (e.g., in URLs)
          // Uses gen_random_bytes() for high entropy + custom charset
          table
            .string('id', 16)
            .primary()
            .defaultTo(
              pg.raw(`
                substring(
                  translate(
                    encode(
                      sha256(
                        (random()::text || clock_timestamp()::text || random()::text)::bytea
                      ),
                      'hex'
                    ),
                    '0123456789abcdef',
                    'A0a1B2b3C4c5D6d7E8e9F0f1G2g3H4h5I6i7J8j9K0k1L2l3M4m5N6n7O8o9P0pQ1qR2rS3sT4tU5uV6vW7wX8xY9yZ0z'
                  )
                  FROM 1 FOR 16
                )
              `)
            );
          break;

        default:
          // Fallback to biginteger if an invalid or undefined type is provided
          // Ensures the table is always created successfully
          table.bigIncrements('id').primary();
      }

      // Add created_at and updated_at columns if timestamps are enabled
      // Second arg: use timezone (true), third arg: default to now() for both columns
      if (timestamps ?? true) {
        table.timestamps(true, true);
      }

      // Add a comment/description to the table if provided
      if (tableComment) {
        table.comment(tableComment);
      }
    });

    if (presentation !== undefined) {
      setTableMetadata(schemaName, tableName, {
        uiName: presentation?.uiName || null,
      });
    }

    return { message: `Table ${fullTableName} created successfully` };
  }

  async updateTable({
    schemaName = 'public',
    tableName,
    data,
  }: {
    schemaName?: string;
    tableName: string;
    data: {
      tableName?: string;
      tableUiName?: string | null;
      tableComment?: string | null;
      presentation?: {
        uiName?: string | null;
      } | null;
    };
  }) {
    const {
      tableName: newTableName,
      tableComment: newTableComment,
      presentation: newPresentation,
    } = data;
    const fullTableName = `${schemaName}.${tableName}`;
    const schemaBuilder = pg.schema.withSchema(schemaName);

    const exists = await schemaBuilder.hasTable(tableName);
    if (!exists) {
      throw new Error(`Table ${fullTableName} not found`);
    }

    let finalTableName = tableName;
    if (newTableName && newTableName !== tableName) {
      const newExists = await pg.schema
        .withSchema(schemaName)
        .hasTable(newTableName);
      if (newExists) {
        throw new Error(`Table ${schemaName}.${newTableName} already exists`);
      }

      await pg.schema
        .withSchema(schemaName)
        .renameTable(tableName, newTableName);
      finalTableName = newTableName;
    }

    if (newTableComment !== undefined) {
      await pg.schema
        .withSchema(schemaName)
        .alterTable(finalTableName, (table) => {
          table.comment(newTableComment ?? '');
        });
    }

    if (newPresentation !== undefined) {
      const metadata: { uiName?: string | null } = {};
      if (newPresentation === null) {
        metadata.uiName = null;
      } else {
        metadata.uiName = newPresentation.uiName;
      }
      setTableMetadata(schemaName, finalTableName, metadata);
    }

    return { message: `Table ${fullTableName} updated successfully` };
  }

  async deleteTable({
    schemaName = 'public',
    tableName,
    cascade = false,
  }: {
    schemaName?: string;
    tableName: string;
    cascade?: boolean;
  }) {
    const fullTableName = `${schemaName}.${tableName}`;
    const schemaBuilder = pg.schema.withSchema(schemaName);

    const exists = await schemaBuilder.hasTable(tableName);
    if (!exists) {
      throw new Error(`Table ${fullTableName} not found`);
    }

    if (cascade) {
      await pg.raw(
        `DROP TABLE IF EXISTS "${schemaName}"."${tableName}" CASCADE;`
      );
    } else {
      await schemaBuilder.dropTable(tableName);
    }

    return { message: `Table ${fullTableName} deleted successfully` };
  }

  async createColumn({
    schemaName = 'public',
    tableName,
    column,
  }: {
    schemaName?: string;
    tableName: string;
    column: {
      name: string;
      nullable?: boolean;
      unique?: boolean;
      defaultValue?: any | null;
      comment?: string | null;
      presentation?: {
        uiName?: string;
        format?: string;
      } | null;
      validation?: {
        minLength?: number | null;
        maxLength?: number | null;
        minValue?: number | null;
        maxValue?: number | null;
        minDate?: string | null;
        maxDate?: string | null;
        maxSize?: number | null;
        maxFiles?: number | null;
        allowedDomains?: string | null;
      } | null;
    } & (
      | {
          dataType: typeof DataType.Select | typeof DataType.MultiSelect;
          options: string[];
          foreignKey?: null;
        }
      | {
          dataType: typeof DataType.Reference;
          foreignKey: {
            table: string;
            column: { name: string; type: string };
            onUpdate: ReferentialAction;
            onDelete: ReferentialAction;
          };
          options?: null;
        }
      | {
          dataType: Exclude<
            DataType,
            | typeof DataType.Select
            | typeof DataType.MultiSelect
            | typeof DataType.Reference
          >;
          options?: null;
          foreignKey?: null;
        }
    );
  }) {
    const {
      name,
      dataType,
      nullable,
      unique,
      defaultValue,
      comment,
      presentation,
      validation,
      options,
      foreignKey,
    } = column;
    const {
      minLength,
      maxLength,
      minValue,
      maxValue,
      minDate,
      maxDate,
      maxSize,
      maxFiles,
      allowedDomains,
    } = validation || {};

    const fullTableName = `"${schemaName}"."${tableName}"`;
    const schemaBuilder = pg.schema.withSchema(schemaName);

    const tableExists = await pg.schema
      .withSchema(schemaName)
      .hasTable(tableName);
    if (!tableExists) throw new Error(`Table ${fullTableName} not found`);

    const columnExists = await pg.schema
      .withSchema(schemaName)
      .hasColumn(tableName, name);
    if (columnExists)
      throw new Error(`Column "${name}" already exists in ${fullTableName}`);

    try {
      await schemaBuilder.alterTable(tableName, (tableBuilder) => {
        const columnBuilder = specificType(pg, tableBuilder, {
          name,
          dataType,
          foreignKey,
        });

        if (nullable) columnBuilder.nullable();
        else columnBuilder.notNullable();

        if (unique) columnBuilder.unique();

        if (defaultValue !== undefined && defaultValue !== null) {
          switch (dataType) {
            case DataType.MultiSelect:
              columnBuilder.defaultTo(toPgArray(defaultValue));
              break;
            case DataType.Attachment:
            case DataType.Reference:
              // Not support default value
              break;
            default:
              columnBuilder.defaultTo(defaultValue);
          }
        }

        if (comment) columnBuilder.comment(comment);

        // Length Check: Only if at least one boundary (min or max) is defined
        if (minLength !== undefined || maxLength !== undefined) {
          addLengthCheck(tableBuilder, tableName, name, minLength!, maxLength!);
        }

        // Range Check: Only if a minimum or maximum value is specified
        if (minValue !== undefined || maxValue !== undefined) {
          addRangeCheck(tableBuilder, tableName, name, minValue!, maxValue!);
        }

        // Date Range Check: Only if start or end dates are provided
        if (minDate || maxDate) {
          addDateRangeCheck(tableBuilder, tableName, name, minDate!, maxDate!);
        }

        // Size Check: Only if a maximum size limit is set
        if (maxSize !== undefined) {
          addSizeCheck(tableBuilder, tableName, name, maxSize);
        }

        // File Count Check: Only if a maximum file limit is set
        if (maxFiles !== undefined) {
          addFileCountCheck(tableBuilder, tableName, name, maxFiles);
        }

        // Email Domain Check
        if (allowedDomains !== undefined) {
          addEmailDomainCheck(tableBuilder, tableName, name, allowedDomains!);
        }

        // Options Check: Only if the options array is not empty
        if (options?.length) {
          addOptionsCheck(
            tableBuilder,
            tableName,
            name,
            options,
            dataType === DataType.MultiSelect
          );
        }
      });

      if (presentation !== undefined) {
        setColumnMetadata(schemaName, tableName, name, {
          uiName: presentation?.uiName || null,
          format: presentation?.format || null,
        });
      }
    } catch (error) {
      // Drop column
      await pg.raw(`ALTER TABLE ?? DROP COLUMN IF EXISTS ??`, [
        tableName,
        name,
      ]);

      throw error;
    }

    return (await getTableSchema(pg, schemaName, tableName, name))[0];
  }

  async updateColumn({
    schemaName = 'public',
    tableName,
    columnName,
    column,
  }: {
    schemaName?: string;
    tableName: string;
    columnName: string;
    column: {
      name: string;
      dataType: DataType;
      nullable: boolean;
      unique: boolean;
      defaultValue: any | null;
      comment: string | null;
      presentation?: {
        uiName?: string | null;
        format?: string | null;
      } | null;
      validation: {
        minLength?: number | null;
        maxLength?: number | null;
        minValue?: number | null;
        maxValue?: number | null;
        minDate?: string | null;
        maxDate?: string | null;
        maxSize?: number | null;
        maxFiles?: number | null;
        allowedDomains?: string | null;
      } | null;
    } & (
      | {
          dataType: typeof DataType.Select | typeof DataType.MultiSelect;
          options: string[];
          foreignKey?: null;
        }
      | {
          dataType: typeof DataType.Reference;
          foreignKey: {
            table: string;
            column: { name: string; type: string };
            onUpdate: ReferentialAction;
            onDelete: ReferentialAction;
          };
          options?: null;
        }
      | {
          dataType: Exclude<
            DataType,
            | typeof DataType.Select
            | typeof DataType.MultiSelect
            | typeof DataType.Reference
          >;
          options?: null;
          foreignKey?: null;
        }
    );
  }) {
    const {
      name: newName,
      dataType,
      nullable,
      unique,
      defaultValue,
      comment,
      presentation,
      validation,
      options,
      foreignKey,
    } = column;
    const {
      minLength,
      maxLength,
      minValue,
      maxValue,
      minDate,
      maxDate,
      maxSize,
      maxFiles,
      allowedDomains,
    } = validation || {};

    const fullTableName = `"${schemaName}"."${tableName}"`;

    const tableExists = await pg.schema
      .withSchema(schemaName)
      .hasTable(tableName);
    if (!tableExists) throw new Error(`Table ${fullTableName} not found`);

    const columnExists = await pg.schema
      .withSchema(schemaName)
      .hasColumn(tableName, columnName);
    if (!columnExists)
      throw new Error(`Column "${columnName}" not found in ${fullTableName}`);

    const [oldSchema] = (await getTableSchema(
      pg,
      schemaName,
      tableName,
      columnName
    )) as Column[];

    let recreateConstraints = false;

    await pg.schema
      .withSchema(schemaName)
      .alterTable(tableName, (tableBuilder) => {
        const columnBuilder = specificType(pg, tableBuilder, {
          name: columnName,
          dataType: dataType || oldSchema.dataType,
          foreignKey,
        }).alter();

        if (newName !== oldSchema.name) {
          tableBuilder.renameColumn(columnName, newName);
          recreateConstraints = true;
        }

        if (nullable !== oldSchema.nullable) {
          if (nullable === true) columnBuilder.nullable();
          else if (nullable === false) columnBuilder.notNullable();
        }

        if (unique !== oldSchema.unique) {
          if (unique === true) columnBuilder.unique();
          else if (unique === false) tableBuilder.dropUnique([columnName]);
        }

        if (defaultValue !== oldSchema.defaultValue) {
          switch (dataType) {
            case DataType.MultiSelect:
              columnBuilder.defaultTo(toPgArray(defaultValue));
              break;
            case DataType.Attachment:
            case DataType.Reference:
              // Not support default value
              break;
            default:
              columnBuilder.defaultTo(defaultValue);
          }
        }

        if (comment !== oldSchema.comment) {
          columnBuilder.comment(comment || '');
        }

        if (
          recreateConstraints ||
          minLength !== oldSchema.validation?.minLength ||
          maxLength !== oldSchema.validation?.maxLength
        ) {
          if (!recreateConstraints) {
            const constraintName = getConstraintName(
              tableName,
              columnName,
              'range'
            );
            if (
              oldSchema.metadata.constraints?.find(
                (c: any) => c.constraint_name === constraintName
              )
            ) {
              removeLengthCheck(tableBuilder, tableName, columnName);
            }
          }

          addLengthCheck(
            tableBuilder,
            tableName,
            newName,
            minLength!,
            maxLength!
          );
        }

        if (
          recreateConstraints ||
          minValue !== oldSchema.validation?.minValue ||
          maxValue !== oldSchema.validation?.maxValue
        ) {
          if (!recreateConstraints) {
            const constraintName = getConstraintName(
              tableName,
              columnName,
              'range'
            );
            if (
              oldSchema.metadata.constraints?.find(
                (c: any) => c.constraint_name === constraintName
              )
            ) {
              removeRangeCheck(tableBuilder, tableName, columnName);
            }
          }

          addRangeCheck(tableBuilder, tableName, newName, minValue!, maxValue!);
        }

        if (
          recreateConstraints ||
          minDate !== oldSchema.validation?.minDate ||
          maxDate !== oldSchema.validation?.maxDate
        ) {
          if (!recreateConstraints) {
            const constraintName = getConstraintName(
              tableName,
              columnName,
              'range'
            );
            if (
              oldSchema.metadata.constraints?.find(
                (c: any) => c.constraint_name === constraintName
              )
            ) {
              removeDateRangeCheck(tableBuilder, tableName, columnName);
            }
          }

          addDateRangeCheck(
            tableBuilder,
            tableName,
            newName,
            minDate!,
            maxDate!
          );
        }

        if (recreateConstraints || maxSize !== oldSchema.validation?.maxSize) {
          if (!recreateConstraints) {
            const constraintName = getConstraintName(
              tableName,
              columnName,
              'size'
            );
            if (
              oldSchema.metadata.constraints?.find(
                (c: any) => c.constraint_name === constraintName
              )
            ) {
              removeSizeCheck(tableBuilder, tableName, columnName);
            }
          }

          addSizeCheck(tableBuilder, tableName, newName, maxSize!);
        }

        if (
          recreateConstraints ||
          maxFiles !== oldSchema.validation?.maxFiles
        ) {
          if (!recreateConstraints) {
            const constraintName = getConstraintName(
              tableName,
              columnName,
              'file-count'
            );
            if (
              oldSchema.metadata.constraints?.find(
                (c: any) => c.constraint_name === constraintName
              )
            ) {
              removeFileCountCheck(tableBuilder, tableName, columnName);
            }
          }

          addFileCountCheck(tableBuilder, tableName, newName, maxFiles!);
        }

        if (
          recreateConstraints ||
          allowedDomains !== oldSchema.validation?.allowedDomains
        ) {
          if (!recreateConstraints) {
            const constraintName = getConstraintName(
              tableName,
              columnName,
              'email-domain'
            );
            if (
              oldSchema.metadata.constraints?.find(
                (c: any) => c.constraint_name === constraintName
              )
            ) {
              removeEmailDomainCheck(tableBuilder, tableName, columnName);
            }
          }

          addEmailDomainCheck(
            tableBuilder,
            tableName,
            newName,
            allowedDomains!
          );
        }

        if (
          recreateConstraints ||
          JSON.stringify(options) !== JSON.stringify(oldSchema.options)
        ) {
          if (!recreateConstraints) {
            const constraintName = getConstraintName(
              tableName,
              columnName,
              'options'
            );
            if (
              oldSchema.metadata.constraints?.find(
                (c: any) => c.constraint_name === constraintName
              )
            ) {
              removeOptionsCheck(tableBuilder, tableName, columnName);
            }
          }
          addOptionsCheck(
            tableBuilder,
            tableName,
            newName,
            options!,
            dataType === DataType.MultiSelect
          );
        }
      })
      .then(() => {
        if (recreateConstraints) {
          return pg.raw(
            `
            ALTER TABLE public."${tableName}"
            DROP CONSTRAINT IF EXISTS "${getConstraintName(
              tableName,
              columnName,
              'length'
            )}",
            DROP CONSTRAINT IF EXISTS "${getConstraintName(
              tableName,
              columnName,
              'range'
            )}",
            DROP CONSTRAINT IF EXISTS "${getConstraintName(
              tableName,
              columnName,
              'date-range'
            )}",
            DROP CONSTRAINT IF EXISTS "${getConstraintName(
              tableName,
              columnName,
              'size'
            )}",
            DROP CONSTRAINT IF EXISTS "${getConstraintName(
              tableName,
              columnName,
              'file-count'
            )}",
            DROP CONSTRAINT IF EXISTS "${getConstraintName(
              tableName,
              columnName,
              'email-domain'
            )}",
            DROP CONSTRAINT IF EXISTS "${getConstraintName(
              tableName,
              columnName,
              'options'
            )}";
          `
          );
        }
      });

    if (presentation !== undefined) {
      const metadata: { uiName?: string | null; format?: any | null } = {};
      if (presentation === null) {
        metadata.uiName = null;
        metadata.format = null;
      } else {
        metadata.uiName = presentation.uiName;
        metadata.format = presentation.format;
      }
      setColumnMetadata(schemaName, tableName, newName, metadata);
    }

    return (await getTableSchema(pg, schemaName, tableName, newName))[0];
  }

  async deleteColumn({
    schemaName = 'public',
    tableName,
    columnName,
  }: {
    schemaName?: string;
    tableName: string;
    columnName: string;
  }) {
    const fullTableName = `"${schemaName}"."${tableName}"`;

    const tableExists = await pg.schema
      .withSchema(schemaName)
      .hasTable(tableName);
    if (!tableExists) throw new Error(`Table ${fullTableName} not found`);

    const columnExists = await pg.schema
      .withSchema(schemaName)
      .hasColumn(tableName, columnName);
    if (!columnExists)
      throw new Error(`Column "${columnName}" not found in ${fullTableName}`);

    await pg.schema
      .withSchema(schemaName)
      .alterTable(tableName, (tableBuilder) => {
        tableBuilder.dropColumn(columnName);
      });
  }
}
